## Note: 
This section doesn't cover exactly how to write PHP, it covers concepts of PHP and explains them at an abstract level, very rarely giving exact code snippets.
<br>
The reason for this is that there are thousands of tutorials out there that walk you through writing the code, but I wanted to create a tutorial explaining how it works and does what it does, and why you should or shouldn't use it!

# What is PHP?
PHP is a server-side scripting language, which means that code gets executed on the server when you make requests to PHP pages.
<br>
This is good, because it allows you (as the Dev) to write complex systems, without exposing a lot of the inner-workings or confidential parts to clients -> which client-side scripting languages do.
<br><br>
PHP has been around for ages as one of the first Server-side hosting frameworks, and as such, is very closely tied to CSS and HTML. 
<br>
It's so closely linked to HTML that it's actually able to return HTML pages or elements to the code that calls it (JavaScript, for example).


## How does PHP work?
When the web server gets a request of "Give me file x", it reads that file from the server's disk and sees that it's got PHP code within the file.
<br>
It then grabs the PHP part of the file and passes it to the PHP interpreter (Which is on the server), to execute the PHP code.
<br>
<br>
The PHP Script will pass back clean data to the interpreter when it finishes, to display on the client browser.
<br>
So, when a PHP script is detected and processed by the Interpreter, the PHP script returns HTML-code, and the Interpreter patches the new HTML (that replaces the PHP script part) and old HTML (if there was any) together to create a full document, which it then returns to the calling function/client (Likely JavaScript or other client-side scripting language).
<br>
<i>Note: Some Web Developers force their servers to pass any html files to the interpreter to hide that they use php from users as an obfuscation technique.</i>
<br>
<br>
PHP is a scripting language, and scripts only exist when you call them, for as long as their internal code takes to execute,
<br>
So if you go to the same page 2x, you might get the impression that you're interacting with a static application, but you're actually interacting with 2x totally different scripts or applications.
<br>
<br>
PHP scripts are lightweight, small and usually handle only a single purpose per script, so you'd use multiple files to build a system - not just one big PHP file.
<br>
Each of these scripts only exist when you call them and only run for as long as their internal code takes to complete, then they get cleared and their memory freed to improve resource efficiency.
<br>
They aren't static applications on the web server, and the web server cleans up the memory usage by destroying those objects once you've finished the call, to improve system performance.
<br>
This is part of what make scripting languages like PHP and Python so fantastic and fast, while remaining incredibly lightweight. 
<br>
While PHP is considered older and more difficult to use than modern technologies - like NodeJS - it outperforms them in resource management and efficiency, since it's had 30 years to mature into the technology that it is today.

# Returning data from PHP
PHP can only pass back an html file by default. 
<br>
To test this theory, create a test html file, and change the file extension to ".php" (Change the end part of the filename from .html to .php).
<br>
You'll just see the regular html again when you open it in your browser - if you're hosting the site via a Web Server.
<br>
<br>
Every Echo statement from PHP returns either HTML, XML, plaintext or JSON structures, but the server will treat it as regular Text enclosed in a paragraph tag if not explicitly stated what the type is.
<br>
Any client-side language (like JavaScript) that listens directly to the result will treat the data as HTML tags, which can cause some issues if you're passing back JSON and your JavaScript can't interpret it properly.


## Do I need the PHP tags in my PHP files?
If you have ONLY PHP code in a file, you can leave out the closing tag ?>.
<br>
This is actually considered a good practice because it prevents excess-whitespace leaks from your code.
<br>
<br>
That being said though, the opening php tag is required for the interpreter to know what language it is, so you need to include that in your file, but you can leave the closing tag out.

## Variable Syntax
Always place the $ (dollar sign) in front of all variable names (In both declaration and usage). 
<br>
In theory, this lets the Interpreter work faster, since it immediately knows it's working with a variable.
<br>
Practically, this is required for variables, or you'll get errors and won't be able to execute your code.
<br>
You don't need to use $ with constants, but you can only globally define those with the define() method, which is PHP's special syntax for defining global constants, or like in the "Method-scoped Constants" section below.

## And/Or vs &&/||
The "and" and "or" keywords are interchangeable with "&&" and "||" respectively, 
<br>
But the latter (&&/||) should always be used because they are of higher order/precedence to the PHP interpreter and execute faster.
<br>
There may be some cases where you'd need to use "or" over "||",
<br>
But this is only where you'd need a second statement to execute if the first failed, which "||" can't inherently do. 
<br>
You should generally avoid using "and" and "or" over the higher precedent keywords.

## Incrementation
doing this
```php
$x = 10;
if ($x++ == 10) echo $x; //echoes 11
```
is different to this:

```php
$x = 10;
if (++$x == 10) echo $x; //never executes
```
<br>
The first block of code will first check x against 10, and if it passes, increment it (so echo will be 11)
<br>
The second block of code will first increment x to 11, then check it against 10, and won't echo anything, since the condition will evaluate to false, as 11 does not equal 10.

## Global Variables
A key note on the scope of variables: Anything that's declared outside of a method, can't be directly accessed by code within methods.
<br>
This means that, by design, every function should do its work in isolation, without storing lots of data in system memory.
<br>
There are, however, cases in the real world, where we need to do this.
<br>
To access member variables inside of functions, we can "declare" global variables within our functions using the <i>"global"</i> keyword before using them in our code.
<br>
I say "declare" here, because we aren't actually redeclaring them, we're just telling PHP that "this variable was actually declared outside of this function, but it does still exist and we can still use it", and PHP will then search for that variable and find it when the script is compiled and executed.
<br>
This concept is similar to C/C++ preprocessor directives, since it works similar to the Define directives.
<br>
<br>
To "redeclare" a variable, we declare it as "global $ourVarName;" at the start of the method, to access the variable from within a method from any subsequent point thereafter. 
<br>

## Static Variables
These are a bit weird and different to Java or C#.
<br>
They will remain in memory throughout the lifetime of the script's execution - even if different instances of the method are spawned by other parts of the script, the same variable's object will be used to access/update data.
<br>
So basically, the variable still exists, even after the method data has been cleared off the stack.
<br>
This is good and bad, and naturally carries performance considerations.
<br>
<br>
<i>A question: won't the compiler encounter the line where the static variable is defined, and just redefine it - thereby clearing it's data?</i>
<br>
The lines where static variables are declared will be skipped the next time the function runs because the compiler will tell the interpreter to ignore their re-declarations, which prevents the script from destroying their data - until the script terminates.
<br>
<br>
Remember: Static variables ONLY exist for this current script. They do not exist when the user refreshes/reloads the page, or when the script terminates/ends. All of the memory will be cleared and recycled by the server to safeguard it's own performance.
<br>

## SUPERGLOBALS:
These are inputs/variables passed into the script by the Web Server itself. 
<br>
In most cases, it'll be stuff like the $_POST or $_GET methods from users entering info in HTML and posting it to the server via JavaScript.
<br>
<br>
This is SUPER dangerous if the inputs are unsanitized, because hackers can compromise front-end systems built in client-side scripting languages like JavaScript, to insert malicious payloads into your PHP scripts. If you don't handle these cases properly, hackers can gain direct access to your server.
<br>
Luckily, PHP has a few really good built-in methods that we can use to protect our systems - which we'll discuss later.
<br>
<br>
Basically, these SuperGlobal variables are global variables that we can access from anywhere in our script - without defining them as "global" first. 
<br>
The first part of the name, "Super", tells us that it's given to us by PHP itself.
<br>
<br>
Super = given by PHP itself.
<br>
Global = accessible from any method.

## True/False vs TRUE/FALSE
For TRUE and FALSE statements, use "true" and "false" instead, because the lowercase version can't be redefined - whereas uppercase can be. 
<br>
This is also important when using 3rd party libraries, since many PHP Web Developers often have their own definitions in their libraries.

## Booleans
A Boolean is a type of value that can only be one of two things: on (true) or off (false).
<br>
They are heavily inspired by logic gates and the actual flow of electricity inside computers, and are super important in computer science and programming, because we use them for decisions.
<br>
<br>
PHP treats TRUE as 1 (on), and FALSE as nothing (off) - NOT 0. 
<br>
This means that trying to print TRUE will print out 1, and printing out FALSE will print out nothing at all.
<br> 
You can still use it same as other languages, it's just a bit strange for newcomers to PHP and programming, and it requires some nullchecking when using false for decisions in certain cases.

## Loosely-typed
PHP is a loosely typed language, so it will auto-convert variables into the right data type where it sees fit.
<br>
For example, it'll convert "1" into an int if I say: If("1" == 1)
<br>
This is great, but can cause some unexpected results as well.
<br>
To force it to do the comparison WITHOUT conversion - using the variables as-is - use the 3x equals "===" signs. 
<br>
This makes it do comparisons with data as-is, causing our example to be FALSE, because "1" does not equal 1, since they're different data types (String of character literals vs Integer).

Another example is:
```php
$a = "100";
$b = "+100";
	
if($a == $b) echo "this is TRUE, because PHP turned both to numbers and 100 is the same as +100";
if($a === $b) echo "this is FALSE and the echo will never output, because we're comparing the strings as-is, and they do not match";
```

## Echo vs Print
In theory, they're both the same, implemented as constructs and don't need parentheses -> (), but print and echo commands are practically different.
<br>
Because print is implemented as a function, it can be used as part of logic, like ternary: 
```php
if($a==1) ? print "works" : print "failed";
```
<br>
Whereas the echo command can't be used in logic, because it just echoes everything to the end of the line or string, causing logical operations to not execute, and get printed out as-is, instead.

## Switch and Case Statements
Switches allow you to perform an IF on a specific variable, to see if the value matches a given condition (Just like an IF statement).
<br>
Switches contain multiple Cases, which act as the actual "if-else" logic.
<br>
Case statements are super useful for reducing the size of code files and repeating words, since IF-ELSE blocks often have repeating cases -> like :
```php
if($name=="Jim") {
  handleJim();
}
if($name=="James") {
  handleJames();
}
if($name=="Frank") {
  handleFrank();
}
```
<br>
Using a Switch/Case, we can remove repeating words, and help speed up the execution of our scripts, while mitigating the probability that we'll have a typo somewhere.
<br>
<br>
You can use them interchangeably with IF-Else statements, and should use them when there's lots of IF statements, to improve efficiency, readability and reduce the chance of human-error!
<br>
<br>
The actual code starts inside of the first colon, and ends at the "break;"
<br>
Example: 
<br>
```php
switch($name){
  case "Jim": 
   handleJim(); 
   break;
  case "James": 
   handleJames(); 
   break;
  case "Frank": 
   handleFrank(); 
   break;
}
```
<br>
From our example, you can see that we've removed repeating code like <i>"if($name =="</i>, which helps to make the code more readable and maintainable, while reducing the possibility of human error
<br>

## Grouping Loops
This is a MASSIVE design choice - and could introduce bugs, but you can actually group multiple FOR LOOPS together into one!
<br>
Normal nested FOR LOOP Example:
```php
for($a=0; $a<10; $a++){
  for($b=0; $b<9; $b++){
    //do domething
  }
}
Grouped FOR LOOP Example:
```php
for($a=0, $b=0; $a<10, $b<9; $a++, $b++) {
  //do domething
}
```
<br>
<br>
Naturally, each for loop has 3x parts (assignment, logical condition, incrementation) so we separate each with a Semi-Colon,
<br>
For grouping FOR LOOPS, we add and separate each group's expressions into each of those 3x parts, with a comma separating each group.
<br>
Basically, we do a regular for-loop and combine the inner loops with the main one, separating each section with a comma.

## The break command
In most languages, the break command can be used to stop execution of a LOOP.
<br>
"break" is super powerful in PHP though, and can do slightly more.
<br>
"break" followed by a number tells the app how many layers to break out of,
<br>
So - in other words - if you've got 3x inner loops, and use "break 2;", it will break out to the highest loop and continue execution - instead of stopping entirely!

## Functions vs Objects [1 vs many]
In PHP, Functions are blocks of code that we define for reusability.
<br>
This makes app loading faster because each function is compiled only once, no matter how often it's called, and decreases programming errors, and improves our ability to make changes.
<br>
PHP Objects are groups of functions and the data they use, they are called <i>Classes</i>.
<br>
<br>
Methods are defined as "function myFuncName" and classes are defined as "class myClassName". Like so:
```php
function myFunc(){
  //local variables and calls to other functions in here
}

class myClass {
  //constructor, destructor and other methods inside here
}
```
<br>
Classes/Objects will have a constructor, destructor and some functions within them - but functions can be standalone as well, being able to exist outside of classes.

## Passing by Reference
Pass-by-reference is deprecated in newer versions of PHP
<br>
But, Receive-by-reference is allowed!
<br>
<br>
With passbyref, we use "&" before a variable name when calling a method, like so: <i>test(&$variableA)</i>
<br>
With receiveByRef, we call it normally (without the &), and we define the function as having the &, like so:
```php
function test(&$variableA) {
  //do something
}
```
<br>
This allows us to still do exactly what we wanted to, and the syntax is a bit weird now, but any changes we make to VariableA will change the original, not a copy of it.

## Referencing other code within our PHP files
There are some keywords we'd use to reference other files, and we'd usually do it at the start of our PHP script. 
<br>
<br>
Here's a quick breakdown of the keywords and what they do:
<br>
"include": allows us to ref another file
<br>
"include_once": allows us to ref another file without cyclic references
<br>
Both of these above only TRY to include the file, and wont fail if there's an error
<br>
"require": fails if the file can't be reffed
<br>
"require_once": is the same as include_once and fails if the file can't be reffed
<br>
<br>
Our "_once" methods ensure that there's no cyclic references. 
<br>
Cyclic references/dependencies are basically where you've referenced "file 1" from "file 2", and you're now referencing "file 2" from "file 1", so they both reference each other, and neither can load until the other does.

## Checking that a function exists
"function_exists" allows us to search the name of a specific function in standard PHP and UDF functions. 
<br>
This is awesome for compatibility with older and new versions of PHP

## Cloning objects
All objects (class objects) are passed by reference - even when we clone them
<br>
Example:
```php
$person1->name = "amy";
$person2 = $person1;
$person2->name = "sally";
```
<br>
Both Person objects now have the name "sally" because we created a reference to Person1 when we created Person2, then we changed it's name - thus changing original Person1
<br>
<br>
To get around this, use the "clone" keyword, this will copy the object!
```php
$person2 = clone $person1
```

## Constructors
When we create objects, we sometimes need to initialize some values at declaration, so we create constructor methods inside the object.
<br>
We use the "function __construct()" keyword (2x underscores _ + construct) to declare a constructor


## Destructors
We do this to basically kill off an object once we no longer need it or once the method is done running and we need to clear memory, like if we need to close conn to a DB, etc.
<br>
<br>
EVERY class needs a destructor method, because the resource was created within the class, so it can only be released there. 
<br>Most errors/memory-leaks come from failure to deconstruct resources once they're done/used
<br>
<br>
We use the "function __destruct()" keyword to declare a destructor/destroyer, then add our code inside of the function

## $this
the "$this" keyword is same as C#/java/Python.
It lets us access only the current object's properties

## Method-scoped Constants
Unlike the global-scoped constants, we can declare constants within methods using the "const" keyword - they still don't have the variable "$" sign though!
<br>
We can also access them directly (within that class/object) using the "self::" + the name of the const to access


## Accessing methods of classes directly
We can do this calling ClassName::MethodName(), BUT the method/function must be declared as Static!
<br>
ALSO, remember that any other methods/functions this method references from within in the same class need to be called as ClassName::MethodName() as well!

## Something cool on Static vars
Classes can also have static member vars that tell you info about all instances of the class - like how many Users logged in, etc.
<br>
These are declared within the class as "static $abc" and then used as normal - they are normal static vars and will keep their data across multiple instances of the class
<br>
These are great for tracking how many people visited your site, etc.!

## Class and Object basics
We use "->" on an object to access its public data or non-static methods
<br>
We use "::" on a class to access a static method

## Advanced Classes and static access
We can declare anything within a class as static, to make it context-agnostic (the data within it doesn't change depending on how many times we use it, or where we use it),
<br>
But the way that we access these objects differs.
<br>
For methods, we need to use the ClassName :: MethodName()
<br>
For member variables, we need to use ClassName :: MemberName()
<br>
If you access static members from within the same class, we need to use Self :: MemberName()
<br>
<br>
Like so:
```php
    $temp = new Test();
    echo "Valid: " . Test::get10() . "\r\n";
    echo "Valid: " . Test::$myTest. "\r\n";
    //cant do this because we're trying to access instance data on a static object (the var is static)
    echo "Invalid: " . $temp->myTest . "\r\n";
    echo Test::test1(). "\r\n";
    echo Test::test2(). "\r\n";
class Test{
    static $myTest = "hello world";
    
    static function get10(){
        return 10;
    }
    static function test1()
    {
        //static methods need to use "Self" to access any other static methods/members within the current class
        return Self::$myTest;
    }
    static function test2()
    {
        return Self::test1();
    }
}
```
## Classes and Inheritance:
I think the easiest way to describe this is in the scope of "Publishers" and "Subscribers" (or consumers).
<br>
If you think about a publishing company - whether it's Game Dev, News or Media - the Publisher is "making something available for others to use".
<br>
This is a pretty important concept in most languages, because we can act as a publisher to parts of our app, and make our lives a lot easier by writing less code.
<br>
<br>
In some cases, we may find that we need a whole bunch of very similar Classes, with similar data and methods.
<br>
I'll use an example of Aeroplanes/planes (this thought was inspired by Microsoft Flight Simulator™).
<br>
<br>
There are many different types of planes out there, from fighter jets and Boeings to WW2 bombers (I don't know much about planes).
<br>
All have a very well defined shape that characterizes them,
<br>
They all have wings, combustion engines that propel them, a seat for the pilot and potential passengers (thereby a maximum carry load and passenger load) and they're all made of similar sturdy materials.
<br>
<br>
If we were writing a game (Microsoft Flight Simulator™) that had planes (Microsoft Flight Simulator™)
<br>
We would have to sit and write exactly the same code for each of these types of planes, and then - within each Class - make small changes for the different types of engines and fueling systems, etc.
<br>
This is fine, until we realize that something we previously assumed to be correct (like combustion engines) has now changed, and we need to individually change 1000+ classes, and then retest every one for failures/differences, etc.
<br>
<br>
This would not only introduce lots of risk and effort - and testing effort, it would also be a massive waste of time.
<br>
The easier solution would be to have a single class/blueprint that has all of these basic common traits (has wings, has combustion engine, has seats, is made of metal, etc.) in one place,
<br>
And then, for each type of plane, we'd "clone" that class/blueprint and just add whatever else we need that's specific to that type of plane.
<br>
<br>
Luckily for us, we're not the first ones to think of this or encounter this dilemma.
<br>
The creators of most languages have added support for "Inheritance", which is exactly the solution we came up with.
<br>
<br>
By having a class "inherit" from another, it gets all the attributes and methods of the "Parent" class.
<br>
So by inheriting from the "Plane" class, our "Boeing" class would now automatically have all the same attributes as a regular plane, and we can still customize/extend it to however we need.
<br>
<br>
Inheritance is pretty easy, you just use the "extends" keyword followed by the name of the Parent class.
<br>
<br>
something slightly tricky on Inheritance is that: if you create a method with the same name as the Parent class, PHP will execute the new method instead of the parent.
<br>
If you ever need to reference the Parent method within this new method, just use "Parent :: ParentMethodName"()
<br>
You can also declare the Parent method as a "final function", which tells PHP to never override it. So instead of "public/private", you'd use the "final" keyword.
<br>
<br>
It's also generally advised to use "Self"::"methodName" within a child class, to ensure that you're calling the right methods from within the current class, etc.
<br>
<br>
When you create a constructor within a child-class, it wont call the constructor of the Parent class, so you'll need to manually call "Parent::__construct()" within your constructor

## Concatenation
PHP doesn't use the + operator for concatenations, it uses a fullstop (.) instead, like Perl.

# PHP Arrays
Probably the most complicated thing in PHP.
<br>
Arrays allow us to deal with more complex data structures, and also allow some pretty easy ways to access data - while remaining quick and efficient.
<br>
<br>
There are Numeric and Associative arrays.
<br>
<b>Numeric arrays</b> are where we use integer indexes to store or access data.
<br>
<b>Associative arrays</b> are where we use words/keyword to store or access data.

## Array Functions
## inserting into Numeric Arrays:
```php
	$arr[] = "hello";
	$arr[] = "world!";
```
This basically tells PHP to create a numeric array and place the data at the next available location in that array - PHP then increments the element count (which starts at 0) and waits for future insertions
<br>
We could also have specified the exact locations to insert into like this:
```php
	$arr[0] = "hello";
	$arr[1] = "world!";
```
<br>
## Getting items from a numeric array:
```php
	$arr[] = "hello";
	$arr[] = "world!";

	echo $arr[0] . " " . $arr[1]; //echo "hello world!"
```
## Associative arrays:
These are basically maps, or Key-value-pairs.
<br>
We can store and access data using "tags", like so:
```php
	//store data in specific tags
	$arr["first"] = "hello";
	$arr["second"] = "world!";
	
	//get data from specific tag
	echo $arr["second"]; //echo "world!"
```
These types of Arrays are super useful when we're extracting info from HTML or XML, because those datatypes may be presented to our code in Key-value-pairs.

## Creating Numeric Arrays with the Array keyword:
```php
$arr = array("hello", "world!"); //this tells PHP to create a new numeric array and add these items
```
retrieving items will still be the same as with regular Numeric Arrays

## Creating Associative Arrays with the Array keyword:
```php
	$arr = array("first" => "hello", 
		     "second" =>"world!");
```
retrieving items will still be the same as with regular Associative Arrays

## FOREACH item AS something:
This allows us to iterate over every element in an array/list
<br>
The syntax is as follows
```php
	foreach($listName as $item)
	{
	    //do something with the $item
	}
```
for associative arrays, the syntax can be as follows:
```php
	foreach($listName as $item => $value) //allows us to access both the Key and Value of the item
	{
	    //do something with the $item and $value, can use both individually now
	}
```
## Multidimensional Arrays:
Arrays within arrays! That's literally all these are.
<br>
The reason we may need them is for applications where we need to store items that fit a certain category - like books.
<br>
Each book has an author, and a genre.
<br>
<br>
For simplicity, I'll use Genre and book name.
<br>
<br>
Imagine we wanted a simple list that said:
<br>
[Category : Book Name]
<br>
Horror : Call of Cthulhu, Data Structures and algorithms, Twilight
<br>
Mystery : At the mountains of Madness
<br>
<br>
How would we implement this?
<br>
<br>
The easiest way is to treat each category like its own array/list, then have those different arrays/lists in another bigger list called "books",
<br>
like so:
```php
	$books = array(
		"Horror" => array("Call of Cthulhu", "Data Structures and algorithms", "Twilight"),
		"Mystery" => array("At the mountains of Madness")
	);
```
The following code will now print out the names of each of the books and the category they belonged to
```php
    foreach($books as $category => $name)
    {
        $leng = count($name);
	//remember that we created the inner array as a numeric array, so we cant access it with tags, need to use for loop!
        for($i=0; $i<$leng; $i++) 
        {
            echo "Category: " . $category . ". Book Name: " . $name[$i] . "<br>";
        }
    }
```
Note: You can also create numeric multidimensional arrays, by simply excluding the tags, like this:
```php
	$books = array(
		array("Call of Cthulhu", "Data Structures and algorithms", "Twilight"),
		array("At the mountains of Madness")
	);
```
Accessing this data is the same as a regular numeric array, but requires 2x for loops


## Some cool built-in array methods:

<ol>
	<li>Explode: 
		<ul>
			<li>Basically C#s equivalent of "string.Split". It allows you to split a string into array elements and insert them into an array</li>
			<li>Syntax: </li>
			<li>$arr = explode(" ", "hello world from CyberFinn!") //this would create 4x array elements. It does so by splitting the string into separate strings based on the instruction (I said " " - which is blank space)</li>
		</ul>
	</li>
	<li>Count: 
		<ul>
			<li>Counts the elements in the array for you</li>
		</ul>
	</li>
	<li>Sort:
		<ul>
			<li>sorts the elements in the array for you</li>
			<li>sorts either SORT_NUMERIC (numbers ascending) or SORT_STRING (Alphabetically)</li>
			<li>syntax: sort($arr, SORT_NUMERIC);</li>
			<li>returns: true if success, false if failure</li>

		</ul>
	</li>
	<li>is_array:
		<ul>
			<li>checks if the object is an array</li>
			<li>syntax: is_array($arr);</li>
			<li>returns: True if it is an array, false if not an array</li>
		</ul>
	</li>
	<li>extract:
		<ul>
			<li>turns key-value-pairs in an array into variables</li>
			<li>Note: if variables conflict with existing ones, the existing ones will be overwritten, so it's advised to use this syntax:</li>
			<li>syntax: extract($GET, EXTR_PREFIX_ALL, "fromGet_"); //this will prefix the new variables with "fromGet_", and will extract all info from the associative GET array into new vars. This is useful for reading data from GET/POSTs</li>
		</ul>
	</li>
	<li>compact:
		<ul>
			<li>turns variables into key-value-pairs (opposite of extract)</li>
			<li>syntax: $arr = compact("variableNameWithout$sign"); //creates associative array where the value of variableNameWithout$sign can be accessed on the array by using the key "variableNameWithout$sign"</li>
		</ul>
	</li>
	<li>reset:
		<ul>
			<li>"foreach.. as.." loops have an internal counter that tells it where it is in the array. Sometimes you may need to reset it to 0 and restart the loop</li>
			<li>syntax: reset($arr)</li>		</ul>
	</li>
	<li>end:
		<ul>
			<li>opposite of reset. it changes the counter to the last element in the list</li>
		</ul>
	</li>
</ol>

## Accessing files on Disk
Note about the Die command: it terminates the current script's execution and closes all resources. 
<br>
This will close any open files, etc. that you're using in your script, but closes the entire app too
<br>
<br>
Sometimes, you may not want to access the db, like when you're handling profile images, etc. -> it may make more sense to just read and store them on disk
<br>
This is where file handling comes in

## File Disk operations:

<ol>
	<li>Checking files exist:
		<ul>
			<li>use the "file_exists" method (returns bool)</li>
		</ul>
	</li>
	<li>creating files:
		<ul>
			<li>note: some systems are case sensitive, so always create files with lower-case names</li>
			<li>
example: 
```php
	$fileHandle = fopen("tes.txt", "w") or die("couldn't create the file"); //w = write mode

	$data = "hello world";

	fwrite($filehandle, $data) or die("failed to write to file");
	fclose($fileHandle);
	echo "success";
```
			</li>
		</ul>
	</li>
	<li>reading files:
		<ul>
			<li>note: easiest way is to read it into a single string, we do this with fgets (file-get-string)</li>
			<li>note: when calculating the number of chars to read, remember to count newline chars too!</li>
			<li>using the same function as above, but replacing the fwrite with the following line - and opening the file in "r" mode:</li>
```php
$fileData = fgets($fileHandle, $numberOfCharactersToRead);
```
		</ul>
	</li>
	<li>Reading an entire file without handles:
		<ul>
			<li>we can use the simple get_file_contents method</li>
			<li>note: this is super useful, because it works over the internet! which fopen doesn't. So we can use it to get HTML, etc from anywhere else, or locally</li>
```php
$fileContents = get_file_contents($filenameAndPath);
```
		</ul>
	</li>
	<li>copying files: 
		<ul>
			<li>note: copy returns a Boolean true if successful, false if failed</li>
```php
	copy($sourceFilePathAndName, $destinationFilePathAndName);
```
		</ul>
	</li>
	<li>moving files:
		<ul>
			<li>note: to move a file, we need to use the "rename" function</li>
			<li>note: you can use "rename" on directories too</li>
```php
	rename($sourceFilePathAndName, $destinationFilePathAndName);
```
		</ul>
	</li>
	<li>deleting files:
		<ul>
			<li>note: to delete files, we use "unlink" which removes it from the filesystem</li>
```php
unlink($filename);
```
		</ul>
	</li>
	<li>File pointers and reading/writing from specific locations:
		<ul>
			<li>File pointers are the index at which the next file operation (read or write) will take place</li>
			<li>File pointers are not the same as the file handle</li>
			<li>we use the "fseek" method to do move the file pointer</li>
			<li>note: fseek has support for specific locations, or for SEEK_END or SEEK_START, which find the end and start of file, respectively</li>
```php
fseek($fileHandle, 0, 100); //0 tells it how many positions backwards/forwards it needs to start from 100 chars in [so only start at 100], this is called the offset and should never exceed seek_end
```
			<li>note: it also has support for SEEK_SET, which sets the file pointer to the given/offset location in the file</li>
```php
fseek($fileHandle, 10, SEEK_SET); //set file pointer to position 10
```
			<li>note: it also has support for SEEK_CURR, which does the same as SEEK_SET, but sets it to the position you're currently at, plus the offset</li>
```php
fseek($fileHandle, 10, SEEK_CURR); //set filepointer to current location + 10 char
```
		</ul>
	</li>
	<li>Locking files:
		<ul>
			<li>This is needed for when multiple users are trying to write to the same file simultaneously, so that the file doesn't get corrupted</li>
			<li>we use the "flock" function (it means "file lock")</li>
			<li>we need to use the following params: LOCK_EX (to lock the file) and LOCK_UN (to unlock the file again)</li>
			<li>note: it's advised to only lock and unlock the file directly before/after you've used the file, then release it asafp -> this is for efficiency and UX</li>
			<li>always wrap the lock in an IF statement, because not all systems will support/allow you to access the file, and it could be locked out too! Always check for a secured/successful lock</li>
```php
flock($fileHandle, LOCK_EX); //lock the file
flock($fileHandle, LOCK_UN); //unlock the file
```
		</ul>
	</li>
	<li>uploading files from a web browser
		<ul>
			<li>seems daunting, but is super easy</li>
			<li>requires some HTML, and specifically the form tag's encoding type of "multipart/form-data"</li>
			<li>note: we don't have to worry about deleting the temp files that get stored on the server, PHP does this for us when we eventually exit</li>
			<li>Client and Server code sample:</li>
```html
	&lt;form method="post" action="upload.php" enctype="multipart/form-data"&gt;
		Select File: &lt;input type="file" name="filename" size="10"&gt;
		&lt;input type="submit" value="Upload"&gt;
	&lt;/form&gt;
```
```php
if($_FILES) //all uploaded files are always stored into this PHP-default associative array
	{
		$name = $_FILES["filename"]["name"];
		//move the file from temp storage (where PHP autosaved it for this run) into the current directory, or new one
		move_uploaded_file($_FILES["filename"]["tmp_name"], $name);
	}
```
			<li>note: On the PHP-side, there are 5x things stored into the $_FILES array, which can only be accessed via the key ["filename"], these are: name, size (in bytes), tempName, error from uploading (if any), type (Internet Media Type -> they have specific names, but represent images, audio, etc.)</li>
			<li>this means that we actually have a few filtering options to defend against zip bombs, etc. and ensure that only the right types are uploaded</li>
		</ul>
	</li>
</ol>

## System calls:
PHP doesn't have all the functionality you need, but the OS (or other custom apps) do!
<br>
In these cases where you need more functionality, you'd use the underlying OS/System. 
<br>
<br>
We do this using the exec (or "Execute") function 
<br>
<i>Note: ALWAYS wrap the input commands to the exec function in an "escapeshellcommand" -> this sanitizes inputs to prevent hacking the OS</i>

## XHMTL or HTML5?
XHTML is interoperable with XML parsers, so it's easy to read in using an xml parser.
<br>
This requires strict validation rules and stricter document formatting and parsing .
<br>
<br>
HTML5 is a lot less strict, but has all the important functionality of XHTML and HTML4,
<br>
It's also a lot simpler to use - and most browsers nowadays (since 2011) use it


## Some notes on MySQL
You should've ideally studied some Database Engineering before working with databases at all, but if you have worked with databases before, or you're a chatGPT expert, it should be pretty easy to use.
<br>
Most databases are pretty easy to use and support the same types of DML queries - despite few syntactical differences
<br>
<br>
If you have AMPPS installed, you can use: "c:\program files\ampps\MySQL\bin\MySQL" -u root -p to open MySQL in command prompt
<br>
you can then use "show databases;" to list all dbs
<br>
then use "use database;" to use a specific db
<br>
then use "show tables;" to show all tables
<br>
then use "describe table;" to describe the columns, etc of the table
<br>
<br>
The MySQL shell also allows you to create databases, etc. from the shell window, if you have administrator access

## PDO and MySQL
MySQL is an incredibly lightweight and well optimized database management system, and is often used with PHP. Because most systems use databases, PHP actually has special methods of connecting to databases.
<br>
The most modern and secure one is PDO, or PHP Data Objects.
<br>
PDO is database independent, and incredibly well optimized for database activity (CRUD). 
<br>
It's lightweight and efficient, but also hides and manages a lot of code for you, to make it super simple
<br>
<br>
PDO also has a method called "quote", which escapes quotes, etc. to prevent sql injections, which is just one of the many functions it has to help you improve system security and efficiency

## Authentication, Session and Cookies:
We often (on large scale sites or web apps) need to keep track of our users,
<br>
we do this via sessions and cookies.
<br>


## Cookies:
A cookie is an item of data that the server saves to your disk via the browser. 
<br>
A cookie can contain up to 4Kb only.
<br>
They can ONLY be read by the issuing site/domain, so that they are inaccessible to other sites/domains
<br>
That being said, some html elements are embedded from multiple sites, and each can store its own cookies -> these are called 3rd party cookies
<br>
Most browsers allow you to disable cookies and 3rd party cookies
<br>
<br>
From the server perspective: cookies are exchanged during the transfer of headers, before the HTML is actually sent, and it's IMPOSSIBLE to send a cookie once html has been sent
<br>
This means that cookies require careful planning and usage
<br>
note: cookies can be edited in the browser, so they're not ideal for storing confidential info like usernames or passwords, etc.
<br>
<br>
creating cookies is easy:

```php
	setcookie(name, value, expiry, path, domain, secure, httponly);
		//value = up to 4kb ONLY
		//expiry = if left empty, expires when browser closes
		//path = path of cookie on server - if nothing, is available only in the current directory, not available on any other site in the domain
		//domain = domain of the cookie -> what domain/subdomain the cookie is available to
		//secure = whether the cookie MUST use secure transfer -> if true, the cookie can only be sent via HTTPS. default is false
```
<br>
Accessing cookies is also easy:
```php
	if(isset($_COOKIE["mycookie"]))
```
Note: You can only access them once the page reloads on the client browser and the client sends the cookie back to the server!
<br>
<br>
Deleting cookies:
<br>
You need to issue it again with a expiry in the past
<br>
You can either manually set it to the past when recreating it, or set the value to FALSE or blank string, and php will do it for you
<br>
The best is to set it a year in the past, because the client date and time might not be correctly set, causing it to still be valid even if you've set it in the past.


## HTTP Authentication:
Uses the web server to manage users and passwords
<br>
<br>
PHP sends a header request asking to start an auth dialog with the browser.
<br>
Server MUST have this turned on, but it's super common and installed with Apache, so it's likely that it's already on
<br>
When going to the site, the user will see a login request page asking for username and password
<br>
once the user has logged in, they won't ever see the login request again, until they've closed the browser, because the browser will keep sending the username and pword to the server until they close it

## Storing user credentials
The best way is to store the username and pword-HASH in MySQL
<br>
We create the hash using the password_hash function, and giving it the PASSWORD_DEFAULT 2nd arg  -> this makes it choose the most secure password alg available
<br>
This method also creates a random salt for the password as well
<br>
<br>
To verify that passwords match the hashes, it's advised that we only use password_verify - which compares a password and a hash to verify if they match, 
<br>
But - because I know Cyber Security - I DEFINITELY DON'T WANT TO DO THAT CHECK ON THE SERVER BECAUSE IT WOULD MEAN TRANSMITTING CLEARTEXT PASSWORDS!!!
<br>
My approach is to first hash the users' password on their machine, and only then send it to our PHP to check. 
<br>
This prevents the user's password from being sniffed or stolen

## Sessions:
We can track users across different site-calls or script executions by setting up hidden fields in forms,but that's inefficient, 
<br>
So PHP handles it for us by storing cookies on the browser that ID that specific user, and allowing us to create Sessions (groups of vars) exists only for them. Nobody else, nothing else can see it or use it.
<br>
The cookies can still be hacked, so watch out for that!
<br>
<br>
Starting a session MUST be done before any html is echoed (like with Cookies)
<br>
<br>
You first start a session with "session_start()", then assign its' variables, etc.
<br>
You can start creating a session's vars by assigning value to it like an associative array:
```php
	$_SESSION["Test"] = "hello world";
```
It's also good practice to store and check the user's IP for the session:
```php
	$_SESSION["ip"] = $_SERVER["REMOTE_ADDR"];
```
Or to store the user agent (if they share the same IP -> for family, etc.):
```php
	$_SESSION["agent"] = $_SERVER["HTTP_USER_AGENT"];
```
Remember that sessions need to be closed as well,
<br>
We do this with session_destroy() -> but ideally, we should clear all cookies and $_SESSION variables too by setting them to null. 
<br>
It's best to create a custom method to do this
<br>
<br>
Sometimes, we might want to leave it up to the server to decide when to log them out of the session.
<br>
We set an expiry in this case, by calling:
```php
ini_set('session.gc_maxlifetime', $duration);
```

## Preventing session fixation
Session Fixation is basically when a hacker creates a bunch of sites, then sends those links to the sessions out and gets users to auth themselves on the session, then they come back and take control of the session
<br>
The best way to defend against it is to use a counter on the site - something like "sessionExists" or "initiated", and if you find that it's true for this session, regenerate the session ID, using "session_regenerate_id"
<br>
<br>
We can also force cookies-only sessions, which prevents this too
We do this with:
```php
ini_set("session.use_only_cookies", 1); 
```
This requires that users have cookies enabled though

## Managing sessions on the server
Sessions need to be placed into nice folders, because the root directory can become messy
<br>
It's probably good to use:
```php
ini_set("session.save_path", "myDesiredDirectory"); 
```
To keep it clean and web-inaccessible (can't be directly accessed by hackers).

## REGEX in PHP:
We use these 3x methods for Regular Expressions: preg_match(), preg_match_all(), preg_replace()
<br>
preg_match is actually pretty powerful because it can take up to 3x arguments and tells us (as the 3rd) what text matched the expression